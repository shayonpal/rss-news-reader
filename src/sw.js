/* eslint-disable */
import { clientsClaim } from "workbox-core";
import { ExpirationPlugin } from "workbox-expiration";
import { precacheAndRoute, cleanupOutdatedCaches } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import {
  StaleWhileRevalidate,
  CacheFirst,
  NetworkFirst,
} from "workbox-strategies";

// Allow service worker to take control immediately
clientsClaim();

// Clean up any previous workbox caches
cleanupOutdatedCaches();

// Precache all static assets generated by Workbox
precacheAndRoute(self.__WB_MANIFEST);

// Cache strategy for static assets (images, fonts, etc.)
registerRoute(
  ({ request }) => request.destination === "image",
  new CacheFirst({
    cacheName: "images",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// Cache strategy for API calls - Network First for fresh data
registerRoute(
  ({ url }) => url.pathname.startsWith("/api/"),
  new NetworkFirst({
    cacheName: "api-cache",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60, // 1 hour
      }),
    ],
  })
);

// Cache strategy for external API calls (Inoreader)
registerRoute(
  ({ url }) => url.hostname === "www.inoreader.com",
  new NetworkFirst({
    cacheName: "inoreader-api",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 6 * 60 * 60, // 6 hours
      }),
    ],
  })
);

// Cache strategy for web fonts
registerRoute(
  ({ url }) =>
    url.origin === "https://fonts.googleapis.com" ||
    url.origin === "https://fonts.gstatic.com",
  new StaleWhileRevalidate({
    cacheName: "google-fonts",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 365 * 24 * 60 * 60, // 1 year
      }),
    ],
  })
);

// Fallback for offline navigation
const FALLBACK_HTML = "/offline";

registerRoute(
  ({ request }) => request.mode === "navigate",
  async (args) => {
    try {
      return await new NetworkFirst({
        cacheName: "pages",
        plugins: [
          new ExpirationPlugin({
            maxEntries: 50,
            maxAgeSeconds: 24 * 60 * 60, // 24 hours
          }),
        ],
      }).handle(args);
    } catch (error) {
      return caches.match(FALLBACK_HTML);
    }
  }
);

// Background sync for read/unread actions (future feature)
self.addEventListener("sync", (event) => {
  if (event.tag === "sync-read-state") {
    event.waitUntil(syncReadState());
  }
});

async function syncReadState() {
  // This will be implemented when we add the sync store
  console.log("Background sync for read state changes");
}

// Handle service worker updates
self.addEventListener("message", (event) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting();
  }
});
